# 1st argument is the path to the snpedia SNP csv file
# 2nd argument is the path to the snpedia genotypes csv file
# 3rd argument is the path to the user's genotype file generated by 23andme

import pandas as pd
import base64
import sys
import numpy as np
import os
import json

import warnings
warnings.filterwarnings("ignore")

if len(sys.argv) == 2:
  if os.path.exists('./data/trait_df.csv') and os.path.exists('./data/equilibrium_df.csv'):
    trait_df_path = './data/trait_df.csv'
    equilibrium_df_path = './data/equilibrium_df.csv'
    geno_path = sys.argv[1]
    population = 'Global'
  else:
    print(f"Usage: python {sys.argv[0]} <trait df> <equilibrium df> <23andMe file> <population>")
    exit()

elif len(sys.argv) == 3:
  if os.path.exists('./data/trait_df.csv') and os.path.exists('./data/equilibrium_df.csv'):
    trait_df_path = './data/trait_df.csv'
    equilibrium_df_path = './data/equilibrium_df.csv'
    geno_path = sys.argv[1]
    population = sys.argv[2]

elif len(sys.argv) == 4:
  trait_df_path = sys.argv[1]
  equilibrium_df_path = sys.argv[2]
  geno_path = sys.argv[3]
  population = 'Global'

elif len(sys.argv) == 5:
  trait_df_path = sys.argv[1]
  equilibrium_df_path = sys.argv[2]
  geno_path = sys.argv[3]
  population = sys.argv[4]

else:
  print(f"Usage: python {sys.argv[0]} <trait df> <equilibrium df> <23andMe file> <population>")
  exit()

try:
  trait_df = pd.read_csv(trait_df_path)
  equilibrium_df = pd.read_csv(equilibrium_df_path)
  geno_df = pd.read_csv(geno_path, sep='\t')
except:
  print("Could not read input files. Please check that the paths are correct.")
  print(f"Usage: python {sys.argv[0]} <trait df> <equilibrium df> <23andMe file> <population>")
  exit()

if population not in trait_df.columns:
  print(f"Population {sys.argv[4]} not found in trait df")
  exit()

class DisjointSet:
  def __init__(self, elements):
    self.parents = {e: e for e in elements}
    self.ranks = {e: 0 for e in elements}

  def find(self, x):
    if self.parents[x] != x:
        self.parents[x] = self.find(self.parents[x])
    return self.parents[x]

  def union(self, x, y):
    xroot = self.find(x)
    yroot = self.find(y)
    if xroot == yroot:
        return
    if self.ranks[xroot] < self.ranks[yroot]:
        self.parents[xroot] = yroot
    elif self.ranks[xroot] > self.ranks[yroot]:
        self.parents[yroot] = xroot
    else:
        self.parents[yroot] = xroot
        self.ranks[xroot] += 1
  
  def get_equivalence_classes(self):
    equivalence_classes = {}
    for x in self.parents:
        xroot = self.find(x)
        if xroot not in equivalence_classes:
            equivalence_classes[xroot] = []
        equivalence_classes[xroot].append(x)
    return equivalence_classes

r2_threshold = 0.2
equilibrium_df = equilibrium_df[equilibrium_df['r2'] >= r2_threshold]

geno_df = geno_df[geno_df['rsid'].isin(trait_df.rsid)]
trait_df = trait_df[trait_df.rsid.isin(geno_df.rsid)]

trait_df = trait_df[pd.notna(trait_df[population])]
trait_df = trait_df[trait_df['OR'] < 10]
trait_df = trait_df[trait_df['OR'] > 0.1]
trait_df = trait_df[trait_df[population] > 0]
trait_df = trait_df[trait_df[population] < 1]
trait_df = trait_df[trait_df['Global'] > 0]
trait_df = trait_df[trait_df['Global'] < 1]
trait_df['direction'] = ['↓' if OR < 1 else '↑' for OR in trait_df['OR']]
traits = pd.value_counts(trait_df.trait)
traits = traits[traits > 0].index
trait_df = trait_df[trait_df.trait.isin(traits)]

trait_df['no_risk_OR'] = trait_df['OR'] ** -(trait_df[population])
trait_df['risk_OR'] = trait_df['OR'] ** (1-trait_df[population])
trait_df['RAF'] = trait_df[population]
# create a dictionary of rsid -> genotype
geno_dict = dict(zip(geno_df.rsid, geno_df.genotype))

risk_results = dict()

all_json = []

for i, trait in enumerate(traits):
  print(f"Processing trait {i+1}/{len(traits)}: {trait}")
  this_trait_df = trait_df[trait_df.trait == trait]
  # filter equilibrium_df for SNPs in this_trait_df
  this_equilibrium_df = equilibrium_df[equilibrium_df.rsid1.isin(this_trait_df.rsid) & equilibrium_df.rsid2.isin(this_trait_df.rsid)]
  # get equivalence classes of SNPs from this_trait_df using this_equilibrium_df as a graph
  equivalence_classes = DisjointSet(this_trait_df.rsid)
  for row in this_equilibrium_df.itertuples():
    equivalence_classes.union(row.rsid1, row.rsid2)
  equivalence_classes = equivalence_classes.get_equivalence_classes()
  classes = list(equivalence_classes.values())
  odds_ratio = 1

  json_rsids = []
  json_chroms = []
  json_positions = []
  json_genotypes = []
  json_risk_alleles = []
  json_directions = []
  json_RAFs = []
  json_ORs = []
  json_percentiles = []

  for c in classes:
    class_df = this_trait_df[this_trait_df.rsid.isin(c)]
    ORs = []
    rsids = []
    chroms = []
    positions = []
    genotypes = []
    risk_alleles = []
    directions = []
    RAFs = []
    percentiles = []

    for row in class_df.itertuples():
      try:
        genotype = geno_dict[row.rsid]
        # check that both letters are in ACGT
        if genotype[0] not in 'ACGT':
          continue
      except:
        continue
      if len(genotype) == 2 and genotype[1] not in 'ACGT':
        continue
      if row.chromosome != 'X' and len(genotype) != 2:
        continue
      if row.chromosome == 'X' and len(genotype) != 2 and len(genotype) != 1:
        continue
      num_risk_alleles = genotype.count(row.risk_allele)
      if len(genotype) == 2:
        OR = row.risk_OR ** num_risk_alleles * row.no_risk_OR ** (2-num_risk_alleles)
      else:
        OR = row.risk_OR ** num_risk_alleles * row.no_risk_OR ** (1-num_risk_alleles)
      ORs.append(OR)
      if row.rsid not in rsids:
        rsids.append(row.rsid)
        chroms.append(row.chromosome)
        positions.append(str(row.position))
        genotypes.append(genotype)
        risk_alleles.append(row.risk_allele)
        directions.append(row.direction)
        RAFs.append(str(round(row.RAF, 3)))
    if len(ORs) > 0:
      json_rsids.append("<br>".join(rsids))
      json_chroms.append("<br>".join(chroms))
      json_positions.append("<br>".join(positions))
      json_genotypes.append("<br>".join(genotypes))
      json_risk_alleles.append("<br>".join(risk_alleles))
      json_directions.append("<br>".join(directions))
      json_RAFs.append("<br>".join(RAFs))
      json_ORs.append(round(np.median(ORs), 3))
      odds_ratio *= np.median(ORs)
  risk_results[trait] = odds_ratio
  result_json = pd.DataFrame({
    'a': json_rsids,
    'b': json_chroms,
    'c': json_positions,
    'd': json_genotypes,
    'e': json_risk_alleles,
    'f': json_directions,
    'g': json_RAFs,
    'h': json_ORs
  })
  result_json = result_json.sort_values(by=['h'], ascending=False)
  result_json = result_json.to_dict('records')
  all_json.append({
    'trait': trait,
    'OR': str(round(odds_ratio, 3)),
    'snps' : result_json
  })

# read the template
with open("trait_template.html", "r") as f:
    template = f.read()

# write the final output to the html file as base-64 encoded strings
with open('trait_report.html', 'w') as f:
  # write the javascript to the html file
  all_json = json.dumps(all_json)
  to_write = base64.b64encode(all_json.encode('utf-8')).decode('utf-8')
  script_text = f"var data = JSON.parse(atob(\"{str(to_write)}\"))"
  f.write(template.format(script_text=script_text))